#include <windows.h>
#include <iostream>
#include <shellapi.h>
#include <fstream>
#include <string>
#include <commdlg.h> // Диалог выбора файла

using namespace std;

// Имя файла для хранения пути последнего запущенного приложения
const wstring configFile = L"last_app.txt";

// Глобальные флаги состояний модификаторов Ctrl и Shift
bool isCtrlPressed = false;
bool isShiftPressed = false;

// Уникальный идентификатор горячего ключа
#define MY_HOTKEY_ID 1

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
wstring GetLastAppPath();
void SaveLastAppPath(const wstring& path);
void OpenFileDialog(HWND hWnd);
void EnsureConfigFileExists(); // Новая функция для создания файла, если его нет

// Правильная сигнатура WinMain с использованием аннотаций
int WINAPI WinMain(
    _In_ HINSTANCE hInstance,
    _In_opt_ HINSTANCE hPrevInstance,
    _In_ LPSTR lpCmdLine,
    _In_ int nCmdShow
)
{
    // Убеждаемся, что файл конфигурации существует
    EnsureConfigFileExists();

    // Регистрация класса окна
    WNDCLASSEX wc = { sizeof(WNDCLASSEX), CS_HREDRAW | CS_VREDRAW,
                      WndProc, 0L, 0L, hInstance, NULL, LoadCursor(NULL, IDC_ARROW),
                      (HBRUSH)(COLOR_WINDOW + 1), NULL, L"MyWindowClass", NULL };

    RegisterClassEx(&wc);

    HWND hwnd = CreateWindow(L"MyWindowClass", L"C++ App",
        WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT,
        800, 600, nullptr, nullptr, hInstance, nullptr);

    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);

    // Регистрация глобального хоткея Ctrl+Shift+F1
    RegisterHotKey(hwnd, MY_HOTKEY_ID, MOD_CONTROL | MOD_SHIFT, VK_F1);

    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Отмена регистрации горячего ключа при закрытии окна
    UnregisterHotKey(hwnd, MY_HOTKEY_ID);

    return static_cast<int>(msg.wParam);
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_COMMAND:
        if (LOWORD(wParam) == 1) // Код команды для кнопки или пункта меню
        {
            OpenFileDialog(hWnd); // Открываем диалог выбора файла
        }
        break;

    case WM_HOTKEY:
        if (LOWORD(wParam) == MY_HOTKEY_ID) // Идентификатор нашего хоткея
        {
            OutputDebugString(L"Произошло нажатие Ctrl+Shift+F1\n");

            wstring lastAppPath = GetLastAppPath();
            if (!lastAppPath.empty())
            {
                OutputDebugString((L"Последний файл: " + lastAppPath + L"\n").c_str()); // Выводим путь в отладчик

                ShellExecute(nullptr, L"open", lastAppPath.c_str(), nullptr, nullptr, SW_SHOWNORMAL);
            }
            else
            {
                MessageBox(hWnd, L"Последнее приложение не найдено.", L"Внимание", MB_OK | MB_ICONWARNING);
            }
        }
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }

    return 0;
}

// Функция чтения пути из файла конфигурации
wstring GetLastAppPath()
{
    wifstream file(configFile);
    wstring result;
    if (file.is_open()) {
        getline(file, result);
        file.close();
    }
    else
    {
        MessageBox(NULL, L"Не удается прочитать файл 'last_app.txt'.", L"Ошибка", MB_OK | MB_ICONERROR);
    }
    return result;
}

// Функция сохранения пути в конфигурационный файл
void SaveLastAppPath(const wstring& path)
{
    wofstream file(configFile, ios_base::trunc); // Режим trunc удаляет старое содержимое
    if (file.is_open()) {
        file << path << endl;
        file.close();
    }
    else
    {
        MessageBox(NULL, L"Не удается записать файл 'last_app.txt'.", L"Ошибка", MB_OK | MB_ICONERROR);
    }
}

// Диалог выбора файла
void OpenFileDialog(HWND hWnd)
{
    OPENFILENAME ofn{};
    wchar_t szFile[MAX_PATH];

    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hWnd;
    ofn.lpstrFilter = L"Все файлы (*.*)\0*.*\0"; // Фильтры файлов
    ofn.nMaxFile = MAX_PATH;
    ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;
    ofn.lpstrFile = szFile;

    if (GetOpenFileName(&ofn))
    {
        wstring selectedFile(szFile);
        SaveLastAppPath(selectedFile); // Сохраняем выбранный файл
        MessageBox(hWnd, L"Файл успешно выбран и сохранён.", L"Успех", MB_OK | MB_ICONINFORMATION);
    }
    else
    {
        MessageBox(hWnd, L"Ничего не выбрано.", L"Ошибка", MB_OK | MB_ICONWARNING);
    }
}

// Функция создания файла, если его нет
void EnsureConfigFileExists()
{
    HANDLE handle = CreateFile(configFile.c_str(),
        GENERIC_WRITE,
        FILE_SHARE_READ,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (handle != INVALID_HANDLE_VALUE)
    {
        CloseHandle(handle);
    }
    else
    {
        MessageBox(NULL, L"Не удалось создать файл 'last_app.txt'.", L"Ошибка", MB_OK | MB_ICONERROR);
    }
}
