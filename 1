#include <windows.h>
#include <iostream>
#include <shellapi.h>
#include <fstream>
#include <string>
#include <commdlg.h> // Диалог выбора файла
#include <shlobj.h>  // Получение иконки приложения

using namespace std;

// Имя файла для хранения пути последнего запущенного приложения
const wstring configFile = L"last_app.txt";

// Глобальные флаги состояний модификаторов Ctrl и Shift
bool isCtrlPressed = false;
bool isShiftPressed = false;

// Уникальный идентификатор горячего ключа
#define MY_HOTKEY_ID 1

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
wstring GetLastAppPath();
void SaveLastAppPath(const wstring& path);
void OpenFileDialog(HWND hWnd);
void DrawInfo(HDC hdc, HWND hWnd);      // Рисуем информацию о приложении
void SetIconFromExe(HWND hWnd, const wstring& path); // Устанавливаем иконку приложения
void EnsureConfigFileExists();          // Создаем файл, если его нет

// Размеры окна
const int WINDOW_WIDTH = 300;
const int WINDOW_HEIGHT = 150;

// Правильная сигнатура WinMain с использованием аннотаций
int WINAPI WinMain(
    _In_ HINSTANCE hInstance,
    _In_opt_ HINSTANCE hPrevInstance,
    _In_ LPSTR lpCmdLine,
    _In_ int nCmdShow
)
{
    // Убеждаемся, что файл конфигурации существует
    EnsureConfigFileExists();

    // Регистрация класса окна
    WNDCLASSEX wc = { sizeof(WNDCLASSEX), CS_HREDRAW | CS_VREDRAW,
                      WndProc, 0L, 0L, hInstance, NULL, LoadCursor(NULL, IDC_ARROW),
                      (HBRUSH)(COLOR_WINDOW + 1), NULL, L"MyWindowClass", NULL };

    RegisterClassEx(&wc);

    HWND hwnd = CreateWindow(L"MyWindowClass", L"Горячая кнопка",
        WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT,
        WINDOW_WIDTH, WINDOW_HEIGHT, nullptr, nullptr, hInstance, nullptr);

    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);

    // Регистрация глобального хоткея Ctrl+Shift+F1
    RegisterHotKey(hwnd, MY_HOTKEY_ID, MOD_CONTROL | MOD_SHIFT, VK_F1);

    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Отмена регистрации горячего ключа при закрытии окна
    UnregisterHotKey(hwnd, MY_HOTKEY_ID);

    return static_cast<int>(msg.wParam);
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_PAINT:
        PAINTSTRUCT ps;
        BeginPaint(hWnd, &ps);
        DrawInfo(ps.hdc, hWnd); // Нарисовать информацию о приложении
        EndPaint(hWnd, &ps);
        break;

    case WM_COMMAND:
        if (LOWORD(wParam) == 1) // Код команды для кнопки или пункта меню
        {
            OpenFileDialog(hWnd); // Открываем диалог выбора файла
        }
        break;

    case WM_HOTKEY:
        if (LOWORD(wParam) == MY_HOTKEY_ID) // Идентификатор нашего хоткея
        {
            OutputDebugString(L"Произошло нажатие Ctrl+Shift+F1\n");

            wstring lastAppPath = GetLastAppPath();
            if (!lastAppPath.empty())
            {
                OutputDebugString((L"Последний файл: " + lastAppPath + L"\n").c_str()); // Выводим путь в отладчик

                ShellExecute(nullptr, L"open", lastAppPath.c_str(), nullptr, nullptr, SW_SHOWNORMAL);
            }
            else
            {
                MessageBox(hWnd, L"Последнее приложение не найдено.", L"Внимание", MB_OK | MB_ICONWARNING);
            }
        }
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }

    return 0;
}

// Функция рисует информацию о последнем открытом приложении
void DrawInfo(HDC hdc, HWND hWnd)
{
    RECT rect;
    GetClientRect(hWnd, &rect);

    wstring lastAppPath = GetLastAppPath();
    wstring infoText = !lastAppPath.empty() ? L"Активное приложение: " + lastAppPath : L"Нет активного приложения.";

    SetBkMode(hdc, TRANSPARENT);
    TextOut(hdc, 10, 10, infoText.c_str(), infoText.length());

    wstring hotkeyHint = L"(Ctrl+Shift+F1)";
    TextOut(hdc, 10, 40, hotkeyHint.c_str(), hotkeyHint.length());
}

// Функция получает иконку из exe-файла и устанавливает её в окно
void SetIconFromExe(HWND hWnd, const wstring& path)
{
    SHFILEINFO shfi = {};
    if (SHGetFileInfo(path.c_str(), 0, &shfi, sizeof(SHFILEINFO), SHGFI_ICON | SHGFI_SMALLICON))
    {
        SendMessage(hWnd, WM_SETICON, ICON_SMALL, reinterpret_cast<LPARAM>(shfi.hIcon));
    }
}

// Функция чтения пути из файла конфигурации
wstring GetLastAppPath()
{
    wifstream file(configFile);
    wstring result;
    if (file.is_open()) {
        getline(file, result);
        file.close();
    }
    else
    {
        MessageBox(NULL, L"Не удается прочитать файл 'last_app.txt'.", L"Ошибка", MB_OK | MB_ICONERROR);
    }
    return result;
}

// Функция сохранения пути в конфигурационный файл
void SaveLastAppPath(const wstring& path)
{
    wofstream file(configFile, ios_base::trunc); // Режим trunc удаляет старое содержимое
    if (file.is_open()) {
        file << path << endl;
        file.close();
    }
    else
    {
        MessageBox(NULL, L"Не удается записать файл 'last_app.txt'.", L"Ошибка", MB_OK | MB_ICONERROR);
    }
}

// Диалог выбора файла
void OpenFileDialog(HWND hWnd)
{
    OPENFILENAME ofn{};
    wchar_t szFile[MAX_PATH];

    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hWnd;
    ofn.lpstrFilter = L"Все файлы (*.*)\0*.*\0"; // Фильтры файлов
    ofn.nMaxFile = MAX_PATH;
    ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;
    ofn.lpstrFile = szFile;

    if (GetOpenFileName(&ofn))
    {
        wstring selectedFile(szFile);
        SaveLastAppPath(selectedFile); // Сохраняем выбранный файл
        SetIconFromExe(hWnd, selectedFile); // Устанавливаем иконку приложения
        InvalidateRect(hWnd, NULL, TRUE); // Пересоздание окна для перерисовки текста
        MessageBox(hWnd, L"Файл успешно выбран и сохранён.", L"Успех", MB_OK | MB_ICONINFORMATION);
    }
    else
    {
        MessageBox(hWnd, L"Ничего не выбрано.", L"Ошибка", MB_OK | MB_ICONWARNING);
    }
}

// Функция создания файла, если его нет
void EnsureConfigFileExists()
{
    HANDLE handle = CreateFile(configFile.c_str(),
        GENERIC_WRITE,
        FILE_SHARE_READ,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (handle != INVALID_HANDLE_VALUE)
    {
        CloseHandle(handle);
    }
    else
    {
        MessageBox(NULL, L"Не удалось создать файл 'last_app.txt'.", L"Ошибка", MB_OK | MB_ICONERROR);
    }
}
