#include <windows.h>
#include <iostream>
#include <shellapi.h>
#include <fstream>
#include <string>

using namespace std;

// Имя файла для хранения путей приложений
const wstring appsListFile = L"apps_list.txt";

// Максимальное число поддерживаемых приложений
const int APP_COUNT = 4;

// Массив путей к приложениям
wstring appPaths[APP_COUNT];

// Уникальные идентификаторы горячих клавиш
#define FIRST_APP_HOTKEY_ID 1
#define SECOND_APP_HOTKEY_ID 2
#define THIRD_APP_HOTKEY_ID 3
#define FOURTH_APP_HOTKEY_ID 4

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
void ReadAppsList();                            // Читаем список приложений из файла
void DrawAppTable(HDC hdc, HWND hWnd);          // Рисуем таблицу с названиями приложений и комбинациями клавиш
void LaunchApp(int index);                      // Запускает приложение по индексу
bool CheckIfFileExists(const wstring& path);    // Проверяет существование файла

// Размеры окна
const int WINDOW_WIDTH = 400;
const int WINDOW_HEIGHT = 200;

// Главная точка входа
int WINAPI WinMain(
    _In_ HINSTANCE hInstance,
    _In_opt_ HINSTANCE hPrevInstance,
    _In_ LPSTR lpCmdLine,
    _In_ int nCmdShow
)
{
    // Загружаем список приложений из файла
    ReadAppsList();

    // Регистрация класса окна
    WNDCLASSEX wc = { sizeof(WNDCLASSEX), CS_HREDRAW | CS_VREDRAW,
                      WndProc, 0L, 0L, hInstance, NULL, LoadCursor(NULL, IDC_ARROW),
                      (HBRUSH)(COLOR_WINDOW + 1), NULL, L"MyWindowClass", NULL };

    RegisterClassEx(&wc);

    HWND hwnd = CreateWindow(L"MyWindowClass", L"Быстрый запуск приложений",
        WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT,
        WINDOW_WIDTH, WINDOW_HEIGHT, nullptr, nullptr, hInstance, nullptr);

    ShowWindow(hwnd, SW_SHOW);
    UpdateWindow(hwnd);

    // Регистрация горячих клавиш
    bool firstRegistered = RegisterHotKey(hwnd, FIRST_APP_HOTKEY_ID, MOD_CONTROL | MOD_SHIFT, VK_F1);
    bool secondRegistered = RegisterHotKey(hwnd, SECOND_APP_HOTKEY_ID, MOD_CONTROL | MOD_SHIFT, VK_F2);
    bool thirdRegistered = RegisterHotKey(hwnd, THIRD_APP_HOTKEY_ID, MOD_CONTROL | MOD_SHIFT, VK_F3);
    bool fourthRegistered = RegisterHotKey(hwnd, FOURTH_APP_HOTKEY_ID, MOD_CONTROL | MOD_SHIFT, VK_F4);

    if (!(firstRegistered && secondRegistered && thirdRegistered && fourthRegistered)) {
        // Подробное сообщение об ошибке регистрации
        wstring errorMsg = L"Не удалось зарегистрировать следующую(-ие) горячую(-ие) клавишу(-и):\n";
        if (!firstRegistered) errorMsg += L"- Ctrl+Shift+F1\n";
        if (!secondRegistered) errorMsg += L"- Ctrl+Shift+F2\n";
        if (!thirdRegistered) errorMsg += L"- Ctrl+Shift+F3\n";
        if (!fourthRegistered) errorMsg += L"- Ctrl+Shift+F4\n";
        MessageBox(hwnd, errorMsg.c_str(), L"Ошибка", MB_OK | MB_ICONERROR);
    }

    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Отмена регистрации горячих клавиш при завершении
    UnregisterHotKey(hwnd, FIRST_APP_HOTKEY_ID);
    UnregisterHotKey(hwnd, SECOND_APP_HOTKEY_ID);
    UnregisterHotKey(hwnd, THIRD_APP_HOTKEY_ID);
    UnregisterHotKey(hwnd, FOURTH_APP_HOTKEY_ID);

    return static_cast<int>(msg.wParam);
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        BeginPaint(hWnd, &ps);
        DrawAppTable(ps.hdc, hWnd); // Рисуем таблицу с названиями приложений
        EndPaint(hWnd, &ps);
    }
    break;

    case WM_HOTKEY:
        switch (wParam)
        {
        case FIRST_APP_HOTKEY_ID:
            LaunchApp(0); // Запустить первое приложение
            break;
        case SECOND_APP_HOTKEY_ID:
            LaunchApp(1); // Запустить второе приложение
            break;
        case THIRD_APP_HOTKEY_ID:
            LaunchApp(2); // Запустить третье приложение
            break;
        case FOURTH_APP_HOTKEY_ID:
            LaunchApp(3); // Запустить четвёртое приложение
            break;
        }
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }

    return 0;
}

// Читаем список приложений из файла
void ReadAppsList()
{
    // Открываем в широких символах
    wifstream file(appsListFile);
    if (!file.is_open()) {
        MessageBox(NULL, L"Не удалось открыть файл настроек.", L"Ошибка", MB_OK | MB_ICONERROR);
        return;
    }

    for (int i = 0; i < APP_COUNT; ++i)
    {
        if (!std::getline(file, appPaths[i])) {
            // Достигнута ли конец файла или произошла ошибка
            appPaths[i].clear();
        }

        // Удалим возможные конечные символы возврата
        if (!appPaths[i].empty() && !appPaths[i].empty()) {
            // Удаление возможных символов CR/LF по крайней мере из конца строки
            if (!appPaths[i].empty() && (appPaths[i].back() == L'\r' || appPaths[i].back() == L'\n')) {
                while (!appPaths[i].empty() && (appPaths[i].back() == L'\r' || appPaths[i].back() == L'\n'))
                    appPaths[i].pop_back();
            }
        }

        if (appPaths[i].empty())
        {
            // Пустая строка
            wcout << L"ReadAppsList: пустая строка на позиции " << i << endl;
        }
        else
        {
            wcout << L"ReadAppsList: path[" << i << L"] = " << appPaths[i] << endl;
        }
    }
    file.close();
}

// Рисуем таблицу с названиями приложений и горячими клавишами
void DrawAppTable(HDC hdc, HWND hWnd)
{
    RECT rect;
    GetClientRect(hWnd, &rect);

    SetBkMode(hdc, TRANSPARENT);

    wstring hotKeys[] = { L"Ctrl+Shift+F1", L"Ctrl+Shift+F2", L"Ctrl+Shift+F3", L"Ctrl+Shift+F4" };

    for (int i = 0; i < APP_COUNT; ++i)
    {
        // Извлекаем имя приложения из пути (получаем название без пути)
        wstring appName;
        if (!appPaths[i].empty()) {
            size_t pos = appPaths[i].find_last_of(L'\\');
            appName = (pos != wstring::npos) ? appPaths[i].substr(pos + 1) : appPaths[i];
        }

        // Формирование строки вида: "<Имя приложения> (<горячая клавиша>)"
        wstring displayText;
        if (!appName.empty()) {
            displayText = appName + L" (" + hotKeys[i] + L")";
        }
        else {
            displayText = L"(пусто) (" + hotKeys[i] + L")";
        }

        // Отображаем строку
        TextOut(hdc, 10, 30 * (i + 1), displayText.c_str(), static_cast<int>(displayText.length()));
    }
}

// Запуск приложения по указанному индексу
void LaunchApp(int index)
{
    if (index >= 0 && index < APP_COUNT && !appPaths[index].empty() &&
        CheckIfFileExists(appPaths[index])) // Проверяем существование файла
    {
        wcout << L"Launching: " << appPaths[index] << endl;
        ShellExecute(NULL, L"open", appPaths[index].c_str(), NULL, NULL, SW_SHOWNORMAL);
    }
    else
    {
        wstring msg = L"Приложение не найдено или не существует.";
        if (!appPaths[index].empty()) {
            msg = L"Не найден файл: " + appPaths[index];
        }
        MessageBox(NULL, msg.c_str(), L"Ошибка запуска", MB_OK | MB_ICONWARNING);
    }
}

// Проверка существования файла с помощью Windows API
bool CheckIfFileExists(const wstring& path)
{
    DWORD attributes = GetFileAttributes(path.c_str());
    return (attributes != INVALID_FILE_ATTRIBUTES && !(attributes & FILE_ATTRIBUTE_DIRECTORY));
}
